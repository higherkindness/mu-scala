<!DOCTYPE html><html><head><title>Mu-Scala: Source generation</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="47 Degrees Open Source" /><meta name="description" content="A purely functional library for building RPC endpoint-based services" /><meta name="og:image" content="/mu-scala/img/poster.png" /><meta name="image" property="og:image" content="/mu-scala/img/poster.png" /><meta name="og:title" content="Mu-Scala: Source generation" /><meta name="title" property="og:title" content="Mu-Scala: Source generation" /><meta name="og:site_name" content="Mu-Scala" /><meta name="og:url" content="https://github.com/higherkindness/mu-scala" /><meta name="og:type" content="website" /><meta name="og:description" content="A purely functional library for building RPC endpoint-based services" /><link rel="icon" type="image/png" href="/mu-scala/img/favicon.png" /><meta name="twitter:title" content="Mu-Scala: Source generation" /><meta name="twitter:image" content="/mu-scala/img/poster.png" /><meta name="twitter:description" content="A purely functional library for building RPC endpoint-based services" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/mu-scala/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/mu-scala/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/mu-scala/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/mu-scala/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/mu-scala/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/mu-scala/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/mu-scala/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/mu-scala/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/mu-scala/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/mu-scala/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/mu-scala/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/mu-scala/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/mu-scala/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/mu-scala/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/mu-scala/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/mu-scala/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/mu-scala/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/mu-scala/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/mu-scala/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/mu-scala/img/favicon310x150.png" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/mu-scala/highlight/styles/github-gist.css" /><link rel="stylesheet" href="/mu-scala/css/light-style.css" /><link rel="stylesheet" href="/mu-scala/css/mu-styles.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><div id="sidebar-brand"><a href="/mu-scala/" class="brand"><div class="brand-wrapper"></div><span>Mu-Scala</span></a><button id="main-toggle" class="sidebar-toggle"><span class="close"></span></button></div><div class="sidebar-nav">                   <div class="sidebar-nav-item  "><a href="/mu-scala/reference" title="Reference" class="">Reference</a></div> <div class="sidebar-nav-item  "><a href="/mu-scala/reference/modules-artifacts" title="Modules and artifacts" class="">Modules and artifacts</a></div> <div class="sidebar-nav-item active "><a href="/mu-scala/reference/source-generation" title="Source generation" class="active">Source generation</a></div> <div class="sidebar-nav-item  "><a href="/mu-scala/reference/schema-evolution" title="Schema Evolution" class="drop-nested">Schema Evolution</a><i class="fa fa-angle-right"></i><div class="sub-section"> <a href="/mu-scala/reference/schema-evolution/avro" title="Avro" class="">Avro</a> <a href="/mu-scala/reference/schema-evolution/proto" title="Protocol Buffers" class="">Protocol Buffers</a></div></div> <div class="sidebar-nav-item  "><a href="/mu-scala/reference/further-reading" title="Further reading" class="">Further reading</a></div></div></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li class="search-nav"><div id="search-dropdown"><label><i class="fa fa-search"></i>Search</label><input id="search-bar" type="text" placeholder="Enter keywords here..." onclick="displayToggleSearch(event)" /><ul id="search-dropdown-content" class="dropdown dropdown-content"></ul></div></li><li id="gh-eyes-item" class="hidden-xs to-uppercase"><a href="https://github.com/higherkindness/mu-scala" target="_blank" rel="noopener noreferrer"><i class="fa fa-eye"></i><span>Watchers<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs to-uppercase"><a href="https://github.com/higherkindness/mu-scala" target="_blank" rel="noopener noreferrer"><i class="fa fa-star-o"></i><span>Stars<span id="stars" class="label label-default">--</span></span></a></li></ul></div></div></div></div><div id="content" data-github-owner="higherkindness" data-github-repo="mu-scala"><div class="content-wrapper"><section><h1 id="source-generation-reference">Source generation reference</h1>

<p>This is a reference page for the <code class="highlighter-rouge">sbt-mu-srcgen</code> sbt plugin, which generates
Scala source code from Avro/Protobuf IDL files.</p>

<h2 id="tasks">Tasks</h2>

<p>The sbt task used to perform source generation depends on your IDL type:</p>

<ul>
  <li>For Avro, use the sbt-mu-srcgen plugin’s <code class="highlighter-rouge">muSrcGen</code> task</li>
  <li>For Protobuf, use the sbt-protoc plugin’s <code class="highlighter-rouge">protocGenerate</code> task
(sbt-mu-srcgen automatically adds the sbt-protoc plugin to your project)</li>
</ul>

<p>Alternatively you can just run the <code class="highlighter-rouge">compile</code> task, and the appropriate source
generation task will be executed before compilation.</p>

<h2 id="settings">Settings</h2>

<p>This section explains each of the sbt plugin’s settings.  As a reminder, this
plugin needs to be manually enabled for any module for which you want to
generate code; you can do that by adding the following to your <code class="highlighter-rouge">build.sbt</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enablePlugins(SrcGenPlugin)
</code></pre></div></div>

<h3 id="musrcgenidltype">muSrcGenIdlType</h3>

<p>The most important sbt setting is <code class="highlighter-rouge">muSrcGenIdlType</code>, which tells the plugin what
kind of IDL files (Avro/Protobuf) to look for.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>muSrcGenIdlType := IdlType.Proto // or IdlType.Avro
</code></pre></div></div>

<h3 id="musrcgenserializationtype">muSrcGenSerializationType</h3>

<p>Another important setting is <code class="highlighter-rouge">muSrcGenSerializationType</code>, which specifies how
messages should be encoded on the wire. This should match the format you chose
for the <code class="highlighter-rouge">muSrcGenIdlType</code> setting:</p>

<ul>
  <li>For Protobuf, there is no need to configure this setting, as there is only one
possible serialization type</li>
  <li>For Avro, choose either <code class="highlighter-rouge">SerializationType.Avro</code> or <code class="highlighter-rouge">SerializationType.AvroWithSchema</code>.
    <ul>
      <li>If you choose <code class="highlighter-rouge">Avro</code>, it means your client and server must always use
exactly the same version of the schema.</li>
      <li>If you choose <code class="highlighter-rouge">AvroWithSchema</code>, the writer schema will be included in
every message sent, which introduces a bandwidth overhead but allows
schema evolution. In other words, the server and client can use different
versions of a schema, as long as they are compatible with each other.  See
the <a href="schema-evolution/avro">schema evolution</a> section for more details on
schema evolution.</li>
    </ul>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>muSrcGenSerializationType := SerializationType.Protobuf // or SerializationType.Avro or SerializationType.AvroWithSchema
</code></pre></div></div>

<h3 id="other-basic-settings">Other basic settings</h3>

<table>
  <thead>
    <tr>
      <th>Setting</th>
      <th>Description</th>
      <th>Default value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">muSrcGenSourceDirs</code></td>
      <td>The list of directories where your IDL files can be found.<br /><br />Note: all the directories configured as sources will be distributed in the resulting jar artifact preserving the same folder structure as in the source.</td>
      <td><code class="highlighter-rouge">Compile / resourceDirectory</code>, typically <code class="highlighter-rouge">src/main/resources/</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">muSrcGenIdlTargetDir</code></td>
      <td>The directory where all discovered IDL files will be copied in preparation for Scala code generation. The plugin will automatically copy the following to the target directory:<br /> * All the IDL files and directories in the directory specified by <code class="highlighter-rouge">muSrcGenSourceDirs</code><br /> * All the IDL files extracted from the JAR files or sbt modules specified by <code class="highlighter-rouge">muSrcGenJarNames</code> (see the “Advanced settings” section below)</td>
      <td><code class="highlighter-rouge">Compile / resourceManaged</code>, typically <code class="highlighter-rouge">target/scala-2.13/resource_managed/main</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">muSrcGenTargetDir</code></td>
      <td>The directory where the <code class="highlighter-rouge">muSrcGen</code> task will write the generated files. The files will be placed in subdirectories based on the namespaces declared in the IDL files.</td>
      <td><code class="highlighter-rouge">Compile / sourceManaged</code>, typically <code class="highlighter-rouge">target/scala-2.13/src_managed/main/</code></td>
    </tr>
  </tbody>
</table>

<p><strong>Note</strong>: The directories referenced in <code class="highlighter-rouge">muSrcGenSourceDirs</code> must exist. Target directories will be created upon generation.</p>

<h3 id="advanced-settings">Advanced settings</h3>

<table>
  <thead>
    <tr>
      <th>Setting</th>
      <th>Description</th>
      <th>Default value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">muSrcGenJarNames</code></td>
      <td>A list of JAR file or sbt module names where extra IDL files can be found. See the <a href="#musrcgenjarnames">muSrcGenJarNames section</a> section below for more details.</td>
      <td><code class="highlighter-rouge">Nil</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">muSrcGenIdlExtension</code></td>
      <td>The extension of IDL files to extract from JAR files or sbt modules.</td>
      <td>* <code class="highlighter-rouge">avdl</code> if <code class="highlighter-rouge">muSrcGenIdlType</code> is <code class="highlighter-rouge">avro</code><br /> * <code class="highlighter-rouge">proto</code> if <code class="highlighter-rouge">muSrcGenIdlType</code> is <code class="highlighter-rouge">Proto</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">muSrcGenCompressionType</code></td>
      <td>The compression type that will be used by generated RPC services. Set to <code class="highlighter-rouge">higherkindness.mu.rpc.srcgen.Model.GzipGen</code> for Gzip compression.</td>
      <td><code class="highlighter-rouge">higherkindness.mu.rpc.srcgen.Model.NoCompressionGen</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">muSrcGenIdiomaticEndpoints</code></td>
      <td>Flag indicating if idiomatic gRPC endpoints should be used. If <code class="highlighter-rouge">true</code>, the service operations will be prefixed by the namespace.</td>
      <td><code class="highlighter-rouge">true</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">muSrcGenProtocVersion</code></td>
      <td>Specifies the protoc version that <a href="https://scalapb.github.io/">ScalaPB</a> should use when generating source files from proto files.</td>
      <td><code class="highlighter-rouge">None</code> (let ScalaPB choose the protoc version)</td>
    </tr>
  </tbody>
</table>

<h3 id="musrcgenjarnames">muSrcGenJarNames</h3>

<p>You can use IDL files packaged into artifacts within your classpath, e.g. JAR
files added to the classpath via <code class="highlighter-rouge">libraryDependencies</code>, or other sbt modules.</p>

<p><code class="highlighter-rouge">muSrcGenJarNames</code> can be very useful when you want to distribute your <code class="highlighter-rouge">IDL</code> files
without binary code (to prevent binary conflicts in clients).</p>

<p>The following example shows how to set up a dependency with another artifact or
sbt module containing the IDL definitions (<code class="highlighter-rouge">foo-domain</code>):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//...
.settings(
  Seq(
      muSrcGenIdlType := IdlType.Avro,
      muSrcGenSerializationType := SerializationType.AvroWithSchema,
      muSrcGenJarNames := Seq("foo-domain"),
      muSrcGenTargetDir := (Compile / sourceManaged).value / "compiled_avro",
      libraryDependencies ++= Seq(
        "io.higherkindness" %% "mu-rpc-service" % V.muRPC
      )
  )
)
//...
</code></pre></div></div>

<h2 id="implementation-notes-an-intentional-incompatibility-with-the-avro-standard">Implementation Notes: An Intentional Incompatibility with the Avro Standard</h2>

<p>In order to make it easier for users to evolve their schemas over time,
<code class="highlighter-rouge">sbt-mu-srcgen</code> intentionally deviates from the Avro standard in one key way: it
restricts RPC return types to record types (<code class="highlighter-rouge">string sendUser(UserWithCountry
user)</code> is not permitted) as well as restricting the arguments of RPC messages to
<em>none</em> or to a single record type (<code class="highlighter-rouge">SendUserResponse sendUser(UserWithCountry
user, RequestId id)</code> is not permitted).</p>

<p>If you attempt to write an Avro schema using primitive types instead of records
(for example, something like this):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@namespace("foo")
protocol UserV1 {
  string sendUser(string user);
}
</code></pre></div></div>

<p>the source generation command (i.e. <code class="highlighter-rouge">muSrcGen</code>) will fail with an error message
explaining why the protocol was rejected. For example, the above schema would trigger
the following message:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[error] (avro-protocol / Compile / muSrcGen) One or more IDL files are invalid. Error details:
[error]  /path/to/the/invalid/file.avdl has the following errors: RPC method request parameter 'user' has non-record request type 'STRING', RPC method response parameter has non-record response type 'STRING'
</code></pre></div></div>

<h3 id="additional-context">Additional Context</h3>

<p>To understand this potential issue with schema evolution, consider the following example,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>record SearchRequest {
  string query;
}

SearchResponse search(SearchRequest request);
</code></pre></div></div>

<p>This schema can be evolved to add optional fields (e.g. ordering, filters, …)
to the request. All the user has to do is just change the <em>single record</em>.</p>

<p>The following API design, on the other hand, can’t be evolved because changing
the <code class="highlighter-rouge">query</code> argument from a <code class="highlighter-rouge">string</code> to any other datatype would introduce
backward incompatibility.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SearchResponse search(string query);
</code></pre></div></div>

<p>For this reason, we <strong>enforce that all requests and responses must be records</strong>.</p>

<p>The reason for disallowing multiple request arguments, on the other hand, is
that the gRPC spec does not support it. There is no obvious way to map multiple
arguments in the Avro RPC definition to a single gRPC request.</p>

</section></div></div></div></div><script src="/mu-scala/highlight/highlight.pack.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/protobuf.min.js"></script><script src="/mu-scala/lunr/lunr.js"></script><script>
// For all code blocks, copy the language from the containing div
// to the inner code tag (where hljs expects it to be)
const langPrefix = 'language-';
document.querySelectorAll(`div[class^='${langPrefix}']`).forEach(function(div) {
  div.classList.forEach(function(cssClass) {
    if (cssClass.startsWith(langPrefix)) {
      const lang = cssClass.substring(langPrefix.length);
      div.querySelectorAll('pre code').forEach(function(code) {
        code.classList.add(lang);
      });
    }
  });
});

hljs.configure({languages:['scala','java','bash','protobuf']});
hljs.initHighlightingOnLoad();
      </script><script>console.info('\x57\x65\x62\x73\x69\x74\x65\x20\x62\x75\x69\x6c\x74\x20\x77\x69\x74\x68\x3a\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x5f\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x5f\x20\x5f\x5f\x0a\x20\x20\x20\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x5f\x20\x20\x2f\x20\x2f\x5f\x20\x20\x20\x20\x20\x20\x5f\x5f\x5f\x5f\x20\x5f\x5f\x5f\x20\x20\x28\x5f\x29\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x28\x5f\x29\x20\x2f\x5f\x5f\x5f\x5f\x20\x20\x5f\x5f\x5f\x5f\x5f\x0a\x20\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x60\x5f\x5f\x20\x5c\x2f\x20\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x5f\x2f\x20\x5f\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x20\x2f\x20\x5f\x5f\x2f\x20\x5f\x20\x5c\x2f\x20\x5f\x5f\x5f\x2f\x0a\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x5f\x2f\x20\x2f\x20\x2f\x5f\x2f\x5f\x5f\x5f\x5f\x5f\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x20\x2f\x5f\x5f\x2f\x20\x2f\x20\x20\x2f\x20\x2f\x5f\x2f\x20\x28\x5f\x5f\x20\x20\x29\x20\x2f\x20\x2f\x5f\x2f\x20\x20\x5f\x5f\x28\x5f\x5f\x20\x20\x29\x0a\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2e\x5f\x5f\x5f\x2f\x5c\x5f\x5f\x2f\x20\x20\x20\x20\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x20\x2f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x2f\x20\x20\x20\x5c\x5f\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x5f\x2f\x5c\x5f\x5f\x2f\x5c\x5f\x5f\x5f\x2f\x5f\x5f\x5f\x5f\x2f\x0a\x0a\x68\x74\x74\x70\x73\x3a\x2f\x2f\x34\x37\x64\x65\x67\x2e\x67\x69\x74\x68\x75\x62\x2e\x69\x6f\x2f\x73\x62\x74\x2d\x6d\x69\x63\x72\x6f\x73\x69\x74\x65\x73')</script><script>((window.gitter = {}).chat = {}).options = {
room: '47deg/mu'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/mu-scala/js/search.js"></script><script src="/mu-scala/js/docs.js"></script></body></html>